-- THIRDPEOPLE
DROP FUNCTION IF EXISTS THIRDPEOPLE_EXISTS;

DELIMITER ;
DELIMITER $$
CREATE FUNCTION THIRDPEOPLE_EXISTS(id_third INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_third FROM thirdpeople b WHERE b.id_third = id_third INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_THIRDPEOPLE -- CREA UN NUEVO REGISTRO 
DELIMITER ;;
CREATE PROCEDURE CREATE_THIRDPEOPLE(IN fullname VARCHAR(16),in contact varchar(20))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO thirdpeople VALUES(NULL, NORMALIZE_TEXT(fullname),NORMALIZE_TEXT(contact));
        COMMIT;
    END;
END;;
DELIMITER ;
DESC thirdpeople;

call CREATE_THIRDPEOPLE('Juan', 'Juanpresi@gmail.com');
select*from thirdpeople;

DROP PROCEDURE IF EXISTS UPDATE_THIRDPEOPLE; -- ACTUALIZA EL NOMBRE DE UNA PERSONA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_THIRDPEOPLE(IN id_third int , IN fullname varchar(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE thirdpeople b SET b.fullname = fullname WHERE b.id_third = id_third;
		COMMIT;
    END;
END;;
DELIMITER ;

call UPDATE_THIRDPEOPLE( 3, 'pancho');

DROP PROCEDURE IF EXISTS DELETE_THIRDPEOPLE; -- ELIMINA UNA PERSONA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

Call DELETE_THIRDPEOPLE(3);

DROP PROCEDURE IF EXISTS GET_THIRDPEOPLE; -- OBTIENE UNA PERSONA DE LA TABLA
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE GET_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

CALL GET_THIRDPEOPLE(2);


-- LOT



DROP FUNCTION IF EXISTS LOT_EXISTS;

DELIMITER ;
DELIMITER $$
CREATE FUNCTION LOT_EXISTS(id_lot INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_lot FROM lot b WHERE b.id_lot = id_lot INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOT; -- CREA UN REGISTRO EN LA TABLA LOT

DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE CREATE_LOT(IN lot_address varchar(80), IN cow_amount int(8))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO lot VALUES(NULL, NORMALIZE_TEXT(lot_address), cow_amount);
		COMMIT;
    END;
END;;
DELIMITER ;

call CREATE_LOT('Salida Norte Estelí 1km al Este', 2);
call CREATE_LOT('Salida SUR Estelí 1km al Este', 4);
Select * from lot;

DROP PROCEDURE IF EXISTS UPDATE_LOT; -- ACTUALIZA EL CONTADOR DE UN LOTE CON EL ID ESPECIFICADO
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOT(IN id_lot int , IN cow_amount int(8))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE lot b SET b.cow_amount = cow_amount WHERE b.id_lot = id_lot;
		COMMIT;
    END;
END;;
DELIMITER ;

CALL UPDATE_LOT(2, 1);


DROP PROCEDURE IF EXISTS DELETE_LOT; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;
CALL DELETE_LOT (2);

DROP PROCEDURE IF EXISTS GET_LOT; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE GET_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;

CALL GET_LOT(3);


-- OPERATION

DROP FUNCTION IF EXISTS OPERATION_EXISTS;

DELIMITER ;
DELIMITER $$
CREATE FUNCTION OPERATION_EXISTS(id_operation INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_operation FROM operation b WHERE b.id_operation = id_operation INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_OPERATIONS; -- CREA UN REGISTRO EN LA TABLA OPERATIONS

DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE CREATE_OPERATIONS(IN id_cow int, in id_third int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO operation VALUES(NULL, id_cow ,  id_third , NORMALIZE_TEXT( operation ));
		COMMIT;
    END;
END;;
DELIMITER ;
select*from cow;
call CREATE_OPERATIONS(1,1,'SALE');

SELECT*FROM operation;


DROP PROCEDURE IF EXISTS UPDATE_OPERATION; -- ACTUALIZA UNA OPERACION CON EL ID ESPECIFICADO
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE UPDATE_OPERATION(IN id_operation int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE operation b SET b.operation = operation WHERE b.id_operation = id_operation;
		COMMIT;
    END;
END;;
DELIMITER ;

call UPDATE_OPERATION(2, 'SALE');

DROP PROCEDURE IF EXISTS DELETE_OPERATION; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE DELETE_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;
CALL DELETE_OPERATION (2);

DROP PROCEDURE IF EXISTS GET_OPERATION; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE GET_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;

CALL GET_OPERATION(1);

-- LOTCOW

DROP PROCEDURE IF EXISTS CREATE_LOT; -- CREA UN REGISTRO EN LA TABLA LOT

DELIMITER ;
DELIMITER ;;
CREATE PROCEDURE CREATE_LOT(IN lot_address varchar(80), IN cow_amount int(8))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO lot VALUES(NULL, NORMALIZE_TEXT(lot_address), cow_amount);
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOTCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_LOTCOW(IN id_lot INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND LOT_EXISTS(id_lot)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA ';
        END IF;
        
		SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		
		INSERT INTO lotcow VALUES(NULL, id_lot, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

CALL CREATE_LOTCOW(1,3);

select* from lotcow;

DROP PROCEDURE IF EXISTS GET_LOTCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_LOTCOW()
BEGIN
	SELECT * FROM lotcow_view;
END;;
DELIMITER ;

CALL GET_LOTCOW;

DROP PROCEDURE IF EXISTS UPDATE_LOTCOW; -- ACTUALIZA EL LOTE 
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOTCOW(IN id INT, IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT LOT_EXISTS(id_lot) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA LOTE';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM lotcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DEL LOTE PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		UPDATE lotcow bc SET bc.id_lot = id_lot WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

CALL UPDATE_LOTCOW(1,3);

DROP PROCEDURE IF EXISTS DELETE_LOTCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOTCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM lotcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

call DELETE_LOTCOW(1);
SELECT*FROM lotcow;