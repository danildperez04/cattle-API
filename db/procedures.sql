DROP FUNCTION IF EXISTS NORMALIZE_TEXT;
DELIMITER $$
CREATE FUNCTION NORMALIZE_TEXT( input VARCHAR(255) )RETURNS VARCHAR(255) DETERMINISTIC
BEGIN
	RETURN TRIM(UPPER(input));
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_EXISTS;
DELIMITER $$
CREATE FUNCTION COW_EXISTS(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA EXISTA
BEGIN
	DECLARE id INT;
	SELECT c.id_cow FROM cow_view c WHERE c.id_cow = id_cow INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_ISALIVE;
DELIMITER $$
CREATE FUNCTION COW_ISALIVE(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA ESTA VIVA
BEGIN
	DECLARE alive INT;
	SELECT c.alive FROM cow_view c WHERE c.id_cow = id_cow INTO alive;
    RETURN alive;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS BREED_EXISTS;
DELIMITER $$
CREATE FUNCTION BREED_EXISTS(id_breed INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA RAZA EXISTA
BEGIN
	DECLARE id INT;
	SELECT b.id_breed FROM breed b WHERE b.id_breed = id_breed INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS BREEDCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION BREEDCOW_EXISTS(id INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id FROM breedcow b WHERE b.id = id INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS DEADCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION DEADCOW_EXISTS(id_death INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGITRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT d.id_death FROM deadcow d WHERE d.id_death = id_death INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS ERROR_RESPONSE;
DELIMITER ;;
CREATE PROCEDURE ERROR_RESPONSE(IN MESSAGE VARCHAR(255))
BEGIN
	SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = MESSAGE;
END;;
DELIMTER ;

-- COWS ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_COWS; -- OBTIENE TODAS LAS VACAS DE LA TABLA
DELIMITER ;; 
CREATE PROCEDURE GET_COWS()
BEGIN
	SELECT * FROM cow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_COW;
DELIMITER ;;
CREATE PROCEDURE GET_COW(IN id_cow INT) -- OBTIENE UNA VACA DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE LA VACA EXISTE
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM cow c WHERE c.id_cow = id_cow;
        COMMIT;
	END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_COW; -- CREA UN REGISTRO EN LA TABLA COW
DELIMITER ;;
CREATE PROCEDURE CREATE_COW(cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO cow VALUES(NULL, NORMALIZE_TEXT(cow_name), NORMALIZE_TEXT(cow_desc), alive, heat, NORMALIZE_TEXT(gender), cow_shoes, dehorned, birth_date);
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_COW; -- ACTUALIZA LOS CAMPOS DE LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_COW(IN id_cow INT, cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN -- COMPROBACION DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE PUEDE HACER NINGUNA OPERACION CON UNA VACA MUERTA';
		END IF;
        IF NOT alive THEN
			CALL CREATE_DEADCOW(id_cow, NULL, CURRENT_DATE());
        END IF;
		UPDATE cow c SET c.cow_name = NORMALIZE_TEXT(cow_name), c.cow_desc = NORMALIZE_TEXT(cow_desc), c.alive = alive, c.heat = heat, c.gender = NORMALIZE_TEXT(gender), c.cow_shoes = cow_shoes, c.dehorned = dehorned, c.birth_date = birth_date WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_COW; -- ELIMINA UNA VACA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_COW(IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		DELETE FROM cow c WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

-- BREED -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDS; -- OBTIENE TODAS LAS RAZAS
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDS()
BEGIN
	SELECT * FROM breed_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_BREED; -- OBTIENE UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREED; -- CREA UN NUEVO REGISTRO PARA LAS RAZAS
DELIMITER ;;
CREATE PROCEDURE CREATE_BREED(IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO breed VALUES(NULL, NORMALIZE_TEXT(breed_name));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREED; -- ACTUALIZA EL NOMBRE DE UNA RAZA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREED(IN id_breed INT, IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE breed b SET b.breed_name = breed_name WHERE b.id_breed = id_breed;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREED; -- ELIMINA UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

-- BREEDCOW --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDCOW()
BEGIN
	SELECT * FROM breedcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREEDCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_BREEDCOW(IN id_breed INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND BREED_EXISTS(id_breed)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- THIS IS A STUPID SOLUTION THO, I THINK THE ONE BELOW IS THE SAME
        -- SELECT bc.id_breed FROM (
-- 			SELECT * FROM breedcow bc WHERE bc.id_cow = id_cow
--         ) bc 
--         WHERE bc.id_breed = id_breed INTO @idAlreadyExists;
		SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		
		INSERT INTO breedcow VALUES(NULL, id_breed, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREEDCOW; -- ACTUALIZA LA RAZA PARA EL REGISTRO ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREEDCOW(IN id INT, IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT BREED_EXISTS(id_breed) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA RAZA';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM breedcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DE LA RAZA PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		UPDATE breedcow bc SET bc.id_breed = id_breed WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREEDCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREEDCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM breedcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

-- DEADCOW ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_DEADCOWS; -- OBTIENE TODAS LAS VACAS MUERTAS
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOWS()
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		SELECT * FROM descriptive_deadcow_view;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_DEADCOW; -- OBTIENE EL REGISTRO DE UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOW(IN id_death INT) -- CAMBIO ACA PORQUE PENSANDOLO BIEN ES UN SIMPLE GET, NO TENDRIA QUE COMPLICARSE TANTO PARA CONSEGUIR UNA RESPUESTA, ADEMAS ESTAMOS HACIENDO LAS CONSULTAS CON LA PROPIA PRIMARY KEY DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
        IF NOT DEADCOW_EXISTS(id_death) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		SELECT * FROM descriptive_deadcow_view d WHERE d.id_death = id_death;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_DEADCOW; -- CREA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE CREATE_DEADCOW(IN id_cow INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE COMO REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'MATALA DOS VECES PUES';
        END IF;
		UPDATE cow c SET c.alive = FALSE WHERE c.id_cow = id_cow;
		INSERT INTO deadcow VALUES(NULL, id_cow, death_cause, death_date);
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_DEADCOW; -- ACTUALIZA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE UPDATE_DEADCOW(IN id INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		UPDATE deadcow d SET d.death_cause = death_cause, d.death_date = death_date WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_DEADCOW; -- ELIMINA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE DELETE_DEADCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		DELETE FROM deadcow d WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;