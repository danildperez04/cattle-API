DROP FUNCTION IF EXISTS NORMALIZE_TEXT;
DELIMITER $$
CREATE FUNCTION NORMALIZE_TEXT( input VARCHAR(255) )RETURNS VARCHAR(255) DETERMINISTIC
BEGIN
	RETURN TRIM(UPPER(input));
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_EXISTS;
DELIMITER $$
CREATE FUNCTION COW_EXISTS(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA EXISTA
BEGIN
	DECLARE id INT;
	SELECT c.id_cow FROM cow_view c WHERE c.id_cow = id_cow INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_ISALIVE;
DELIMITER $$
CREATE FUNCTION COW_ISALIVE(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA EXISTA
BEGIN
	DECLARE alive INT;
	SELECT c.alive FROM cow_view c WHERE c.id_cow = id_cow INTO alive;
    RETURN alive;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS BREED_EXISTS;
DELIMITER $$
CREATE FUNCTION BREED_EXISTS(id_breed INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA RAZA EXISTA
BEGIN
	DECLARE id INT;
	SELECT b.id_breed FROM breed b WHERE b.id_breed = id_breed INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- COWS
DROP PROCEDURE IF EXISTS GET_COWS; -- OBTIENE TODAS LAS VACAS DE LA TABLA
DELIMITER ;; 
CREATE PROCEDURE GET_COWS()
BEGIN
	SELECT * FROM cow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_COW;
DELIMITER ;;
CREATE PROCEDURE GET_COW(IN id_cow INT) -- OBTIENE UNA VACA DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE LA VACA EXISTE
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM cow c WHERE c.id_cow = id_cow;
        COMMIT;
	END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_COW; -- CREA UN REGISTRO EN LA TABLA COW
DELIMITER ;;
CREATE PROCEDURE CREATE_COW(cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO cow VALUES(null, NORMALIZE_TEXT(cow_name), NORMALIZE_TEXT(cow_desc), alive, heat, NORMALIZE_TEXT(gender), cow_shoes, dehorned, birth_date);
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_COW; -- ACTUALIZA LOS CAMPOS DE LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_COW(IN id_cow INT, cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF (NOT COW_ISALIVE(id_cow)) THEN -- COMPROBACION DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE PUEDE HACER NINGUNA OPERACION CON UNA VACA MUERTA';
		END IF;
        IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE cow c SET c.cow_name = NORMALIZE_TEXT(cow_name), c.cow_desc = NORMALIZE_TEXT(cow_desc), c.alive = alive, c.heat = heat, c.gender = NORMALIZE_TEXT(gender), c.cow_shoes = cow_shoes, c.dehorned = dehorned, c.birth_date = birth_date WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_COW; -- ELIMINA UNA VACA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_COW(IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		DELETE FROM cow c WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

-- BREED
DROP PROCEDURE IF EXISTS GET_BREEDS; -- OBTIENE TODAS LAS RAZAS
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDS()
BEGIN
	SELECT * FROM breed_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_BREED; -- OBTIENE UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREED; -- CREA UN NUEVO REGISTRO PARA LAS RAZAS
DELIMITER ;;
CREATE PROCEDURE CREATE_BREED(IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO breed VALUES(null, NORMALIZE_TEXT(breed_name));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREED; -- ACTUALIZA EL NOMBRE DE UNA RAZA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREED(IN id_breed INT, IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE breed b SET b.breed_name = breed_name WHERE b.id_breed = id_breed;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREED; -- ELIMINA UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

-- BREEDCOW
DROP PROCEDURE IF EXISTS GET_BREEDCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDCOW()
BEGIN
	SELECT * FROM breedcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREEDCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_BREEDCOW(IN id_breed INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND BREED_EXISTS(id_breed)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- THIS IS AN STUPID SOLUTION THO, I THINK THAT ONE BELOW IS THE SAME
        -- SELECT bc.id_breed FROM (
-- 			SELECT * FROM breedcow bc WHERE bc.id_cow = id_cow
--         ) bc 
--         WHERE bc.id_breed = id_breed INTO @idAlreadyExists;
		SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		
		INSERT INTO breedcow VALUES(null, id_breed, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREEDCOW; -- ACTUALIZA LA RAZA PARA EL REGISTRO ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREEDCOW(IN id INT, IN id_breed INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND BREED_EXISTS(id_breed)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExist = id_breed THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		
		UPDATE breedcow bc SET bc.id_breed = id_breed WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREEDCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREEDCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF (SELECT bc.id FROM breedcow bc WHERE bc.id = id) IS NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM breedcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;
-- DEADCOW