-- FUNCTIONS
DROP FUNCTION IF EXISTS NORMALIZE_TEXT;
DELIMITER $$
CREATE FUNCTION NORMALIZE_TEXT( input VARCHAR(255) )RETURNS VARCHAR(255) DETERMINISTIC
BEGIN
	RETURN TRIM(UPPER(input));
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_EXISTS;
DELIMITER $$
CREATE FUNCTION COW_EXISTS(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA EXISTA
BEGIN
	DECLARE id INT;
	SELECT c.id_cow FROM cow_view c WHERE c.id_cow = id_cow INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_ISALIVE;
DELIMITER $$
CREATE FUNCTION COW_ISALIVE(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA ESTA VIVA
BEGIN
	DECLARE alive INT;
	SELECT c.alive FROM cow_view c WHERE c.id_cow = id_cow INTO alive;
    RETURN alive;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS BREED_EXISTS;
DELIMITER $$
CREATE FUNCTION BREED_EXISTS(id_breed INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA RAZA EXISTA
BEGIN
	DECLARE id INT;
	SELECT b.id_breed FROM breed b WHERE b.id_breed = id_breed INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS BREEDCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION BREEDCOW_EXISTS(id INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id FROM breedcow b WHERE b.id = id INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS DEADCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION DEADCOW_EXISTS(id_death INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGITRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT d.id_death FROM deadcow d WHERE d.id_death = id_death INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS THIRDPEOPLE_EXISTS;
DELIMITER $$
CREATE FUNCTION THIRDPEOPLE_EXISTS(id_third INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_third FROM thirdpeople b WHERE b.id_third = id_third INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS OPERATION_EXISTS;
DELIMITER $$
CREATE FUNCTION OPERATION_EXISTS(id_operation INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_operation FROM operation b WHERE b.id_operation = id_operation INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS LOT_EXISTS;
DELIMITER $$
CREATE FUNCTION LOT_EXISTS(id_lot INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_lot FROM lot b WHERE b.id_lot = id_lot INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS LOTCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION LOTCOW_EXISTS(id INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id FROM lotcow b WHERE b.id = id INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS ERROR_RESPONSE;
DELIMITER ;;
CREATE PROCEDURE ERROR_RESPONSE(IN MESSAGE VARCHAR(255))
BEGIN
	SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = MESSAGE;
END;;
DELIMTER ;

-- PROCEDURES
-- COWS ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_COWS; -- OBTIENE TODAS LAS VACAS DE LA TABLA
DELIMITER ;; 
CREATE PROCEDURE GET_COWS()
BEGIN
	SELECT * FROM cow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_COW;
DELIMITER ;;
CREATE PROCEDURE GET_COW(IN id_cow INT) -- OBTIENE UNA VACA DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE LA VACA EXISTE
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM cow c WHERE c.id_cow = id_cow;
        COMMIT;
	END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_COW; -- CREA UN REGISTRO EN LA TABLA COW
DELIMITER ;;
CREATE PROCEDURE CREATE_COW(cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO cow VALUES(NULL, NORMALIZE_TEXT(cow_name), NORMALIZE_TEXT(cow_desc), alive, heat, NORMALIZE_TEXT(gender), cow_shoes, dehorned, birth_date);
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_COW; -- ACTUALIZA LOS CAMPOS DE LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_COW(IN id_cow INT, cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN -- COMPROBACION DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE PUEDE HACER NINGUNA OPERACION CON UNA VACA MUERTA';
		END IF;
        IF NOT alive THEN
			CALL CREATE_DEADCOW(id_cow, NULL, CURRENT_DATE());
        END IF;
		UPDATE cow c SET c.cow_name = NORMALIZE_TEXT(cow_name), c.cow_desc = NORMALIZE_TEXT(cow_desc), c.alive = alive, c.heat = heat, c.gender = NORMALIZE_TEXT(gender), c.cow_shoes = cow_shoes, c.dehorned = dehorned, c.birth_date = birth_date WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_COW; -- ELIMINA UNA VACA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_COW(IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		DELETE FROM cow c WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

-- BREED -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDS; -- OBTIENE TODAS LAS RAZAS
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDS()
BEGIN
	SELECT * FROM breed_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_BREED; -- OBTIENE UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREED; -- CREA UN NUEVO REGISTRO PARA LAS RAZAS
DELIMITER ;;
CREATE PROCEDURE CREATE_BREED(IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO breed VALUES(NULL, NORMALIZE_TEXT(breed_name));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREED; -- ACTUALIZA EL NOMBRE DE UNA RAZA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREED(IN id_breed INT, IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE breed b SET b.breed_name = breed_name WHERE b.id_breed = id_breed;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREED; -- ELIMINA UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

-- BREEDCOW --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDCOW()
BEGIN
	SELECT * FROM breedcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREEDCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_BREEDCOW(IN id_breed INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND BREED_EXISTS(id_breed)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- THIS IS A STUPID SOLUTION THO, I THINK THE ONE BELOW IS THE SAME
        -- SELECT bc.id_breed FROM (
-- 			SELECT * FROM breedcow bc WHERE bc.id_cow = id_cow
--         ) bc 
--         WHERE bc.id_breed = id_breed INTO @idAlreadyExists;
		SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		
		INSERT INTO breedcow VALUES(NULL, id_breed, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREEDCOW; -- ACTUALIZA LA RAZA PARA EL REGISTRO ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREEDCOW(IN id INT, IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT BREED_EXISTS(id_breed) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA RAZA';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM breedcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DE LA RAZA PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		UPDATE breedcow bc SET bc.id_breed = id_breed WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREEDCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREEDCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM breedcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

-- DEADCOW ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_DEADCOWS; -- OBTIENE TODAS LAS VACAS MUERTAS
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOWS()
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		SELECT * FROM descriptive_deadcow_view;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_DEADCOW; -- OBTIENE EL REGISTRO DE UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOW(IN id_death INT) -- CAMBIO ACA PORQUE PENSANDOLO BIEN ES UN SIMPLE GET, NO TENDRIA QUE COMPLICARSE TANTO PARA CONSEGUIR UNA RESPUESTA, ADEMAS ESTAMOS HACIENDO LAS CONSULTAS CON LA PROPIA PRIMARY KEY DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
        IF NOT DEADCOW_EXISTS(id_death) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		SELECT * FROM descriptive_deadcow_view d WHERE d.id_death = id_death;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_DEADCOW; -- CREA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE CREATE_DEADCOW(IN id_cow INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE COMO REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'MATALA DOS VECES PUES';
        END IF;
		UPDATE cow c SET c.alive = FALSE WHERE c.id_cow = id_cow;
		INSERT INTO deadcow VALUES(NULL, id_cow, death_cause, death_date);
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_DEADCOW; -- ACTUALIZA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE UPDATE_DEADCOW(IN id INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		UPDATE deadcow d SET d.death_cause = death_cause, d.death_date = death_date WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_DEADCOW; -- ELIMINA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE DELETE_DEADCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		DELETE FROM deadcow d WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;

-- THIRDPEOPLE -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_THIRDPEOPLE; -- OBTIENE UNA PERSONA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_THIRDPEOPLE -- CREA UN NUEVO REGISTRO 
DELIMITER ;;
CREATE PROCEDURE CREATE_THIRDPEOPLE(IN fullname VARCHAR(16),in contact varchar(20))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO thirdpeople VALUES(NULL, NORMALIZE_TEXT(fullname),NORMALIZE_TEXT(contact));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_THIRDPEOPLE; -- ACTUALIZA EL NOMBRE DE UNA PERSONA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_THIRDPEOPLE(IN id_third int , IN fullname varchar(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE thirdpeople b SET b.fullname = fullname WHERE b.id_third = id_third;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_THIRDPEOPLE; -- ELIMINA UNA PERSONA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

-- LOT -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_LOT; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOT; -- CREA UN REGISTRO EN LA TABLA LOT
DELIMITER ;;
CREATE PROCEDURE CREATE_LOT(IN lot_address varchar(80))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO lot(id_lot, lot_address) VALUES(NULL, NORMALIZE_TEXT(lot_address));
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_LOT; -- ACTUALIZA EL CONTADOR DE UN LOTE CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOT(IN id_lot int , IN cow_amount int(8))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE lot b SET b.cow_amount = cow_amount WHERE b.id_lot = id_lot;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_LOT; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;

-- OPERATION -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_OPERATION; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_OPERATIONS; -- CREA UN REGISTRO EN LA TABLA OPERATIONS
DELIMITER ;;
CREATE PROCEDURE CREATE_OPERATIONS(IN id_cow int, in id_third int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO operation VALUES(NULL, id_cow ,  id_third , NORMALIZE_TEXT( operation ));
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_OPERATION; -- ACTUALIZA UNA OPERACION CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_OPERATION(IN id_operation int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE operation b SET b.operation = operation WHERE b.id_operation = id_operation;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_OPERATION; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;

-- LOTCOW ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_LOTCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_LOTCOW()
BEGIN
	SELECT * FROM lotcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOTCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_LOTCOW(IN id_lot INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND LOT_EXISTS(id_lot)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA ';
        END IF;
        
		SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		
		INSERT INTO lotcow VALUES(NULL, id_lot, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_LOTCOW; -- ACTUALIZA EL LOTE 
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOTCOW(IN id INT, IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT LOT_EXISTS(id_lot) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA LOTE';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM lotcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DEL LOTE PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		UPDATE lotcow bc SET bc.id_lot = id_lot WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_LOTCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOTCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOTCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM lotcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;