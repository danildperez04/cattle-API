-- FUNCTIONS
DROP FUNCTION IF EXISTS NORMALIZE_TEXT;
DELIMITER $$
CREATE FUNCTION NORMALIZE_TEXT( input VARCHAR(255) )RETURNS VARCHAR(255) DETERMINISTIC
BEGIN
	RETURN TRIM(UPPER(input));
END$$
DELIMITER ;

-- COW ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS COW_EXISTS;
DELIMITER $$
CREATE FUNCTION COW_EXISTS(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA EXISTA
BEGIN
	DECLARE id INT;
	SELECT c.id_cow FROM cow_view c WHERE c.id_cow = id_cow INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP FUNCTION IF EXISTS COW_ISALIVE;
DELIMITER $$
CREATE FUNCTION COW_ISALIVE(id_cow INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA VACA ESTA VIVA
BEGIN
	DECLARE alive INT;
	SELECT c.alive FROM cow_view c WHERE c.id_cow = id_cow INTO alive;
    RETURN alive;
END$$
DELIMITER ;

-- BREED ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS BREED_EXISTS;
DELIMITER $$
CREATE FUNCTION BREED_EXISTS(id_breed INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE LA RAZA EXISTA
BEGIN
	DECLARE id INT;
	SELECT b.id_breed FROM breed b WHERE b.id_breed = id_breed INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- BREEDCOW -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS BREEDCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION BREEDCOW_EXISTS(id INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id FROM breedcow b WHERE b.id = id INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- DEADCOW --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS DEADCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION DEADCOW_EXISTS(id_death INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGITRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT d.id_death FROM deadcow d WHERE d.id_death = id_death INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- VACCINE --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS VACCINE_EXISTS_NAME; -- VALIDA EL NOMBRE DE LA VACUNA EN VACCINE
DELIMITER $$
CREATE FUNCTION VACCINE_EXISTS_NAME(vaccine_name VARCHAR(16)) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE v_name VARCHAR(16);
    SELECT v.vaccine_name FROM vaccine v WHERE v.vaccine_name = vaccine_name INTO v_name;
    IF v_name IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS VACCINE_EXISTS_ID; -- VALIDA EL ID DE LA VACUNA EN VACCINE
DELIMITER $$
CREATE FUNCTION VACCINE_EXISTS_ID(id_vaccine INT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE id INT;
    SELECT v.id_vaccine FROM vaccine v WHERE v.id_vaccine = id_vaccine INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

-- INVENTORY ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS INVENTORY_EXISTS_VACCINE; --VALIDA EL ID DE LA VACUNA EN EL INVANTRIO
DELIMITER $$
CREATE FUNCTION INVENTORY_EXISTS_VACCINE(id_vaccine INT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE id INT;
    SELECT i.id_vaccine FROM inventory i WHERE i.id_vaccine = id_vaccine INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS INVENTORY_EXISTS_ID; -- VALIDA EL ID DEL INVENTARIO
DELIMITER $$
CREATE FUNCTION INVENTORY_EXISTS_ID(id_inventory INT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE id INT;
    SELECT i.id FROM inventory i WHERE i.id = id_inventory INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS VALIDATE_ML; -- VALIDA SI LA CANTIDAD DE ML EN INVENTARIO ES SUFICIENTE
DELIMITER $$
CREATE FUNCTION VALIDATE_ML(id_vaccine INT, ml_cowvaccine DOUBLE) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE ml_inventory DOUBLE;
    SELECT i.ml FROM inventory i WHERE i.id_vaccine = id_vaccine INTO ml_inventory;
    IF ml_cowvaccine > ml_inventory THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

-- COWVACCINE -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS COWVACCINE_EXISTS_ID; -- VALIDA SI EXISTE REGISTRO DEL ID DE COWVACCINE
DELIMITER $$
CREATE FUNCTION COWVACCINE_EXISTS_ID(id_cowvaccine INT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE id INT;
    SELECT c.id FROM cowvaccine c WHERE c.id = id_cowvaccine INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

-- CLINICHISTORY --------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS CLINICHISTORY_EXISTS_ID; -- VALIDA SI EXISTE REGISTRO DEL ID DE CLINICHISTORY
DELIMITER $$
CREATE FUNCTION CLINICHISTORY_EXISTS_ID(id_clinichistory INT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    DECLARE id INT;
    SELECT c.id FROM clinichistory c WHERE c.id = id_clinichistory INTO id;
    IF id IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS CLINICHISTORY_VALIDAE_WEIGHT; -- VALIDA EL PESO DE LA VACA
DELIMITER $$
CREATE FUNCTION CLINICHISTORY_VALIDAE_WEIGHT(periodic_weight DOUBLE) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    IF periodic_weight < 0 || periodic_weight < 30 || periodic_weight > 1500 THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS CLINICHISTORY_VALIDAE_HEIGHT; -- VALIDA LA ALTURA DE LA VACA
DELIMITER $$
CREATE FUNCTION CLINICHISTORY_VALIDAE_HEIGHT(periodic_weight DOUBLE) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    IF periodic_weight < 0 OR periodic_weight < 0.5 OR periodic_weight > 3 THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END $$
DELIMITER ;

-- THIRDPEOPLE ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS THIRDPEOPLE_EXISTS;
DELIMITER $$
CREATE FUNCTION THIRDPEOPLE_EXISTS(id_third INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_third FROM thirdpeople b WHERE b.id_third = id_third INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- OPERATION ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS OPERATION_EXISTS;
DELIMITER $$
CREATE FUNCTION OPERATION_EXISTS(id_operation INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_operation FROM operation b WHERE b.id_operation = id_operation INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- LOT ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS LOT_EXISTS;
DELIMITER $$
CREATE FUNCTION LOT_EXISTS(id_lot INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id_lot FROM lot b WHERE b.id_lot = id_lot INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

-- LOTCOW ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS LOTCOW_EXISTS;
DELIMITER $$
CREATE FUNCTION LOTCOW_EXISTS(id INT) RETURNS BOOLEAN DETERMINISTIC -- RETORNA VERDADERO EN CASO DE QUE EL REGISTRO EXISTA
BEGIN
	DECLARE idExists INT;
	SELECT b.id FROM lotcow b WHERE b.id = id INTO idExists;
    IF idExists IS NULL THEN
		RETURN FALSE;
    END IF;
	RETURN TRUE;
END$$
DELIMITER ;

DROP PROCEDURE IF EXISTS ERROR_RESPONSE;
DELIMITER ;;
CREATE PROCEDURE ERROR_RESPONSE(IN MESSAGE VARCHAR(255))
BEGIN
	SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = MESSAGE;
END;;
DELIMTER ;

-- PROCEDURES
-- COWS -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_COWS; -- OBTIENE TODAS LAS VACAS DE LA TABLA
DELIMITER ;; 
CREATE PROCEDURE GET_COWS()
BEGIN
	SELECT * FROM cow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_COW;
DELIMITER ;;
CREATE PROCEDURE GET_COW(IN id_cow INT) -- OBTIENE UNA VACA DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE LA VACA EXISTE
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM cow c WHERE c.id_cow = id_cow;
        COMMIT;
	END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_COW; -- CREA UN REGISTRO EN LA TABLA COW
DELIMITER ;;
CREATE PROCEDURE CREATE_COW(cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO cow VALUES(NULL, NORMALIZE_TEXT(cow_name), NORMALIZE_TEXT(cow_desc), alive, heat, NORMALIZE_TEXT(gender), cow_shoes, dehorned, birth_date);
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_COW; -- ACTUALIZA LOS CAMPOS DE LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_COW(IN id_cow INT, cow_name VARCHAR(30), IN cow_desc VARCHAR(10), IN alive BOOLEAN, IN heat DATE, IN gender VARCHAR(10), IN cow_shoes DATE, IN dehorned DATE, IN birth_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN -- COMPROBACION DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE PUEDE HACER NINGUNA OPERACION CON UNA VACA MUERTA';
		END IF;
        IF NOT alive THEN
			CALL CREATE_DEADCOW(id_cow, NULL, CURRENT_DATE());
        END IF;
		UPDATE cow c SET c.cow_name = NORMALIZE_TEXT(cow_name), c.cow_desc = NORMALIZE_TEXT(cow_desc), c.alive = alive, c.heat = heat, c.gender = NORMALIZE_TEXT(gender), c.cow_shoes = cow_shoes, c.dehorned = dehorned, c.birth_date = birth_date WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_COW; -- ELIMINA UNA VACA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_COW(IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COW_EXISTS(id_cow) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_cow); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		DELETE FROM cow c WHERE c.id_cow = id_cow;
		COMMIT;
    END;
END;;
DELIMITER ;

-- BREED ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDS; -- OBTIENE TODAS LAS RAZAS
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDS()
BEGIN
	SELECT * FROM breed_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_BREED; -- OBTIENE UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREED; -- CREA UN NUEVO REGISTRO PARA LAS RAZAS
DELIMITER ;;
CREATE PROCEDURE CREATE_BREED(IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO breed VALUES(NULL, NORMALIZE_TEXT(breed_name));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREED; -- ACTUALIZA EL NOMBRE DE UNA RAZA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREED(IN id_breed INT, IN breed_name VARCHAR(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE breed b SET b.breed_name = breed_name WHERE b.id_breed = id_breed;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREED; -- ELIMINA UNA RAZA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREED(IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREED_EXISTS(id_breed) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_breed);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM breed b WHERE b.id_breed = id_breed;
        COMMIT;
    END;
END;;
DELIMITER ;

-- BREEDCOW -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_BREEDCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_BREEDCOW()
BEGIN
	SELECT * FROM breedcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_BREEDCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_BREEDCOW(IN id_breed INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND BREED_EXISTS(id_breed)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- THIS IS A STUPID SOLUTION THO, I THINK THE ONE BELOW IS THE SAME
        -- SELECT bc.id_breed FROM (
-- 			SELECT * FROM breedcow bc WHERE bc.id_cow = id_cow
--         ) bc 
--         WHERE bc.id_breed = id_breed INTO @idAlreadyExists;
		SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		
		INSERT INTO breedcow VALUES(NULL, id_breed, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_BREEDCOW; -- ACTUALIZA LA RAZA PARA EL REGISTRO ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_BREEDCOW(IN id INT, IN id_breed INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT BREED_EXISTS(id_breed) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA RAZA';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM breedcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UNA RAZA A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DE LA RAZA PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_breed FROM breedcow bc WHERE bc.id_breed = id_breed AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UNA RAZA QUE YA POSEE';
        END IF;
		UPDATE breedcow bc SET bc.id_breed = id_breed WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_BREEDCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_BREEDCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT BREEDCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM breedcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

-- DEADCOW --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_DEADCOWS; -- OBTIENE TODAS LAS VACAS MUERTAS
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOWS()
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		SELECT * FROM descriptive_deadcow_view;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_DEADCOW; -- OBTIENE EL REGISTRO DE UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE GET_DEADCOW(IN id_death INT) -- CAMBIO ACA PORQUE PENSANDOLO BIEN ES UN SIMPLE GET, NO TENDRIA QUE COMPLICARSE TANTO PARA CONSEGUIR UNA RESPUESTA, ADEMAS ESTAMOS HACIENDO LAS CONSULTAS CON LA PROPIA PRIMARY KEY DE LA TABLA
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
        IF NOT DEADCOW_EXISTS(id_death) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		SELECT * FROM descriptive_deadcow_view d WHERE d.id_death = id_death;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_DEADCOW; -- CREA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE CREATE_DEADCOW(IN id_cow INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE COMO REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'MATALA DOS VECES PUES';
        END IF;
		UPDATE cow c SET c.alive = FALSE WHERE c.id_cow = id_cow;
		INSERT INTO deadcow VALUES(NULL, id_cow, death_cause, death_date);
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_DEADCOW; -- ACTUALIZA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE UPDATE_DEADCOW(IN id INT, IN death_cause TEXT, IN death_date DATE)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		UPDATE deadcow d SET d.death_cause = death_cause, d.death_date = death_date WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_DEADCOW; -- ELIMINA UN REGISTRO PARA UNA VACA MUERTA
DELIMITER ;; 
CREATE PROCEDURE DELETE_DEADCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT DEADCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESE REGISTRO';
        END IF;
		DELETE FROM deadcow d WHERE d.id_death = id;
    COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_VACCINES; -- OBTIENE TODAS LAS VACUNAS DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_VACCINES()
BEGIN
    SELECT * FROM vaccine;
END ;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_VACCINE; -- OBTIENE UNA VACUNA ESPECIFICADA
DELIMITER ;;

CREATE PROCEDURE GET_VACCINE( IN id_vaccine INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
        SELECT @p2 AS MESSAGE;
        ROLLBACK;
    END;
    START TRANSACTION;
    BEGIN
        IF NOT VACCINE_EXISTS_ID(id_vaccine) THEN -- COMPROBACION DE QUE LA VACUNA EXISTE
            SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_vaccine);
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM vaccine v WHERE v.id_vaccine = id_vaccine;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_VACCINE; -- CREA UNA VACUNA
DELIMITER ;;
CREATE PROCEDURE CREATE_VACCINE(IN vaccine_name VARCHAR(16), IN vaccine_desc TEXT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
        IF VACCINE_EXISTS_NAME(NORMALIZE_TEXT(vaccine_name)) THEN -- VALIDACIÓN DE QUE EXISTA LA VACUNA
            SET @message = CONCAT('YA EXISTE REGISTRO DE LA VACUNA ', vaccine_name); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;    
        INSERT INTO vaccine VALUES(null, NORMALIZE_TEXT(vaccine_name), NORMALIZE_TEXT(vaccine_desc));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_VACCINE; -- ACTUALIZA UNA VACUNA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE UPDATE_VACCINE(IN id_vaccine INT, IN vaccine_name VARCHAR(16), IN vaccine_desc TEXT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 @P1 = RETURNED_SQLSTATE, @P2 = MESSAGE_TEXT;
        SELECT @P2 AS MESSAGE;
        ROLLBACK;
    END;
    START TRANSACTION;  
    BEGIN
        IF NOT VACCINE_EXISTS_ID(id_vaccine) THEN -- VALIDACIÓN DE QUE EXISTA LA VACUNA
            SET @message = CONCAT('NO HAY REGISTRO DE LA VACUNA ', id_vaccine); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
            UPDATE vaccine v SET v.vaccine_name = NORMALIZE_TEXT(vaccine_name), v.vaccine_desc = NORMALIZE_TEXT(vaccine_desc) WHERE v.id_vaccine = id_vaccine;
        COMMIT;
    END;
END ;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_VACCINE; -- ELIMINA UNA VACUNA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_VACCINE(IN id_vaccine INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT VACCINE_EXISTS_ID(id_vaccine) THEN -- COMPROBACION DE QUE EL REGISTRO EXISTA
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_vaccine); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		DELETE FROM vaccine v WHERE v.id_vaccine = id_vaccine;
		COMMIT;
    END;
END;;
DELIMITER ;

-- INVENTORY ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_INVENTORYS; --OBTIENE TIDOS LOS REGISTROS DEL INVENTARIO
DELIMITER ;;
CREATE PROCEDURE GET_INVENTORYS()
BEGIN
    SELECT * FROM inventory;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_INVENTORY; -- OBTIENE UN REGISTRO ESPECIFICO DEL INVENTARIO
DELIMITER ;;
CREATE PROCEDURE GET_INVENTORY( IN id INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
            SELECT @p2 AS MESSAGE;
            ROLLBACK;
        END;
    START TRANSACTION;
    BEGIN
        IF NOT INVENTORY_EXISTS_ID(id) THEN -- COMPROBACION DE QUE EXISTE REGISTRO DEL ID EN EL INVENTRIO
            SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id);
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM inventory i WHERE i.id = id;
        COMMIT;
    END;    
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_INVENTORY; -- CREA UN REGISTRO EN INVENTARIO
DELIMITER ;;
CREATE PROCEDURE CREATE_INVENTORY(IN id_vaccine INT, IN ml DOUBLE)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
        IF NOT VACCINE_EXISTS_ID(id_vaccine) THEN -- VALIDACIÓN DE QUE EXISTA LA VACUNA PARA PODER METERLA EN INVENTARIO
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACUNA NO EXISTE ';
        END IF;    
        IF INVENTORY_EXISTS_ID(id_vaccine) AND VACCINE_EXISTS_ID(id_vaccine) THEN -- VALIDACIÓN DE QUE YA EXISTA REGISTRO DE LA VACUNA EN INVENTARIO
            SET @message = CONCAT('YA EXISTE REGISTRO DE LA VACUNA CON ID ', id_vaccine); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;    
        INSERT INTO inventory VALUES(null, id_vaccine, ml);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_INVENTORY; -- ACTUALIZA UN REGISTRO EN INVENTERIO
DELIMITER ;;
CREATE PROCEDURE UPDATE_INVENTORY(IN id INT, IN ml DOUBLE)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
        IF NOT INVENTORY_EXISTS_ID(id) THEN -- VALIDACIÓN DE QUE EXISTA REGISTRO EN INVENTARIO
            SET @message = CONCAT('NO HAY REGISTRO EN INVENTARIO DEL ID ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;    
        UPDATE inventory i SET i.ml = ml WHERE i.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_INVENTORY; -- ELIMINA UN REGISTRO DE INVENTARIO
DELIMITER ;;
CREATE PROCEDURE DELETE_INVENTORY(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT INVENTORY_EXISTS_ID(id) THEN -- VALIDACIÓN DE QUE EXISTA REGISTRO EN INVENTARIO
            SET @message = CONCAT('NO HAY REGISTRO EN INVENTARIO DEL ID ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF; 
		DELETE FROM inventory i WHERE i.id = id;
		COMMIT;
    END;
END;;
DELIMITER ;

-- COWVACCINE ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_COWVACCINES; --OBTIENE TODOS LOS REGISTROS DEL COWVACCINE
DELIMITER ;;
CREATE PROCEDURE GET_COWVACCINES()
BEGIN
    SELECT * FROM cowvaccine;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_COWVACCINE; -- OBTIENE UN REGISTRO ESPECIFICO DE COWVACCINE
DELIMITER ;;
CREATE PROCEDURE GET_COWVACCINE( IN id INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
            SELECT @p2 AS MESSAGE;
            ROLLBACK;
        END;
    START TRANSACTION;
    BEGIN
        IF NOT COWVACCINE_EXISTS_ID(id) THEN -- COMPROBACION DE QUE EXISTA REGISTRO DE COWVACCINE
            SET @message = CONCAT('NO EXISTE REGISTRO PARA ID ', id);
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM cowvaccine c WHERE c.id = id;
        COMMIT;
    END;    
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_COWVACCINE; -- CREA UN REGISTRO EN COWVACCINE
DELIMITER ;;
CREATE PROCEDURE CREATE_COWVACCINE(IN id_cow INT, IN id_vaccine INT, IN vaccine_date DATE, IN ml DOUBLE)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
        IF NOT INVENTORY_EXISTS_VACCINE(id_vaccine) THEN -- VALIDACIÓN DE QUE EXISTA LA VACUNA EN INVENTARIO
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACUNA NO EXISTE ';
        END IF;
        IF NOT COW_EXISTS(id_cow) THEN -- VALIDACIÓN DE QUE EXISTA LA VACA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE ';
        END IF;     
        IF (NOT COW_ISALIVE(id_cow)) THEN -- VALIDACIÓN DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VA ESTA MUERTA ';
        END IF;
        IF (NOT VALIDATE_ML(id_vaccine, ml)) THEN -- VALIDACIÓN DE LA CONTIDAD A APLICAR
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO HAY CANTIDAD SUFICIENTE DE VACUNA EN EL INVENTARIO ';
        END IF;    
        INSERT INTO cowvaccine VALUES(null, id_cow, id_vaccine, vaccine_date, ml);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_COWVACCINE; -- CREA UN REGISTRO EN COWVACCINE
DELIMITER ;;
CREATE PROCEDURE UPDATE_COWVACCINE(IN id INT, IN id_cow INT, IN id_vaccine INT, IN vaccine_date DATE, IN ml DOUBLE)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
        IF NOT COWVACCINE_EXISTS_ID(id) THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID INGRESADO PARA LA ACTUALIZACIÓN NO EXISTE';
        END IF;
        IF NOT INVENTORY_EXISTS_VACCINE(id_vaccine) THEN -- VALIDACIÓN DE QUE EXISTA LA VACUNA EN INVENTARIO
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACUNA NO EXISTE ';
        END IF;
        IF NOT COW_EXISTS(id_cow) THEN -- VALIDACIÓN DE QUE EXISTA LA VACA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE ';
        END IF;     
        IF (NOT COW_ISALIVE(id_cow)) THEN -- VALIDACIÓN DE QUE LA VACA ESTE VIVA
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA ESTA MUERTA ';
        END IF;
        IF (NOT VALIDATE_ML(id_vaccine, ml)) THEN -- VALIDACIÓN DE LA CONTIDAD A APLICAR
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO HAY CANTIDAD SUFICIENTE DE VACUNA EN EL INVENTARIO ';
        END IF;    
        UPDATE cowvaccine c SET c.id_cow = id_cow, c.id_vaccine = id_vaccine, c.vaccine_date = vaccine_date, c.ml = ml WHERE c.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_COWVACCINE; -- ELIMINA UN REGISTRO DE INVENTARIO
DELIMITER ;;
CREATE PROCEDURE DELETE_COWVACCINE(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT COWVACCINE_EXISTS_ID(id) THEN -- VALIDACIÓN DE QUE EXISTA REGISTRO EN COWVACCINE
            SET @message = CONCAT('NO HAY REGISTRO EN COWVACCINE DEL ID ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF; 
		DELETE FROM cowvaccine c WHERE c.id = id;
		COMMIT;
    END;
END;;
DELIMITER ;

-- CLINICHISTORY --------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_CLINICHISTORYS; --OBTIENE TODOS LOS REGISTROS DE CLINICHISTORY
DELIMITER ;;
CREATE PROCEDURE GET_CLINICHISTORYS()
BEGIN
    SELECT * FROM clinichistory;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS GET_CLINICHISTORY; -- OBTIENE UN REGISTRO ESPECIFICO DE CLINICHISTORY
DELIMITER ;;
CREATE PROCEDURE GET_CLINICHISTORY( IN id INT)
BEGIN
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
            SELECT @p2 AS MESSAGE;
            ROLLBACK;
        END;
    START TRANSACTION;
    BEGIN
        IF NOT CLINICHISTORY_EXISTS_ID(id) THEN -- COMPROBACION DE QUE HALLA UN REGISTRO DE CLINICHISTORY
            SET @message = CONCAT('NO EXISTE REGISTRO PARA ID ', id);
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM clinichistory c WHERE c.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;
DROP PROCEDURE IF EXISTS CREATE_CLINICHISTORY; -- CREA UN REGISTRO EN CLINICHISTORY
DELIMITER ;;
CREATE PROCEDURE CREATE_CLINICHISTORY(IN id_cow INT, IN id_cowvaccine INT, IN description TEXT, IN periodic_weight DOUBLE, IN periodic_height DOUBLE, IN date DATE, IN img_url TEXT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF (NOT CLINICHISTORY_VALIDAE_HEIGHT(periodic_height)) THEN 
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR AL INGRESAR ALTURA ';
        END IF;
		IF (NOT CLINICHISTORY_VALIDAE_WEIGHT(periodic_weight)) THEN 
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR AL INGRESAR PESO ';
        END IF;
        IF (NOT COW_ISALIVE(id_cow)) THEN -- VALIDACIÓN DE QUE LA VACA ESTE VIVA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA ESTA MUERTA ';
        END IF;
        IF (NOT COW_EXISTS(id_cow)) THEN -- VALIDACIÓN DE QUE EXISTA LA VACA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE ';
        END IF;     
        IF ((id_cowvaccine IS NOT NULL) && (NOT COWVACCINE_EXISTS_ID(id_cowvaccine)) ) THEN -- VALIDACIÓN DEL ID DE COWVACCINE
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO HAY REGISTRO DE EL ID DE COWVACCINE ';
        END IF;    
        INSERT INTO clinichistory VALUES(null, id_cow, id_cowvaccine, description, periodic_weight, periodic_height, date, img_url);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_CLINICHISTORY; -- ACTUALIZA UN REGISTRO EN CLINICHISTORY
DELIMITER ;;
CREATE PROCEDURE UPDATE_CLINICHISTORY(IN id INT, IN id_cow INT, IN id_cowvaccine INT, IN description TEXT, IN periodic_weight DOUBLE, IN periodic_height DOUBLE, IN date DATE, IN img_url TEXT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF (NOT CLINICHISTORY_VALIDAE_HEIGHT(periodic_height)) THEN 
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR AL INGRESAR ALTURA ';
        END IF;
		IF (NOT CLINICHISTORY_VALIDAE_WEIGHT(periodic_weight)) THEN 
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ERROR AL INGRESAR PESO ';
        END IF;
        IF (NOT CLINICHISTORY_EXISTS_ID(id)) THEN -- VALIDACIÓN DE QUE EXISTA LA VACA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE ';
        END IF; 
        IF (NOT COW_EXISTS(id_cow)) THEN -- VALIDACIÓN DE QUE EXISTA LA VACA
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LA VACA NO EXISTE ';
        END IF;     
        IF ((id_cowvaccine IS NOT NULL) && (NOT COWVACCINE_EXISTS_ID(id_cowvaccine)) ) THEN -- VALIDACIÓN DEL ID DE COWVACCINE
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO HAY REGISTRO DE EL ID DE COWVACCINE ';
        END IF;    
        UPDATE clinichistory c SET c.id_cow = id_cow, c.id_cowvaccine = id_cowvaccine, c.description = description, c.periodic_weight = periodic_weight, c.periodic_height = periodic_height, c.date = date, c.img_url = img_url WHERE c.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_CLINICHISTORY; -- ELIMINA UN REGISTRO DE CLINICHISTORY
DELIMITER ;;
CREATE PROCEDURE DELETE_CLINICHISTORY(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
	START TRANSACTION;
    BEGIN
		IF NOT CLINICHISTORY_EXISTS_ID(id) THEN -- VALIDACIÓN DE QUE EXISTA REGISTRO EN CLINICHISTORY
            SET @message = CONCAT('NO HAY REGISTRO EN CLINICHISTORY DEL ID ', id); 
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF; 
		DELETE FROM clinichistory c WHERE c.id = id;
		COMMIT;
    END;
END;;
DELIMITER ;

-- THIRDPEOPLE ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_THIRDPEOPLE; -- OBTIENE UNA PERSONA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_THIRDPEOPLE -- CREA UN NUEVO REGISTRO 
DELIMITER ;;
CREATE PROCEDURE CREATE_THIRDPEOPLE(IN fullname VARCHAR(16),in contact varchar(20))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		INSERT INTO thirdpeople VALUES(NULL, NORMALIZE_TEXT(fullname),NORMALIZE_TEXT(contact));
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_THIRDPEOPLE; -- ACTUALIZA EL NOMBRE DE UNA PERSONA CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_THIRDPEOPLE(IN id_third int , IN fullname varchar(16))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE thirdpeople b SET b.fullname = fullname WHERE b.id_third = id_third;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_THIRDPEOPLE; -- ELIMINA UNA PERSONA DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_THIRDPEOPLE(IN id_third INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_third) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_third);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM thirdpeople b WHERE b.id_third = id_third;
        COMMIT;
    END;
END;;
DELIMITER ;

-- LOT ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_LOT; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOT; -- CREA UN REGISTRO EN LA TABLA LOT
DELIMITER ;;
CREATE PROCEDURE CREATE_LOT(IN lot_address varchar(80))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO lot(id_lot, lot_address) VALUES(NULL, NORMALIZE_TEXT(lot_address));
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_LOT; -- ACTUALIZA EL CONTADOR DE UN LOTE CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOT(IN id_lot int , IN cow_amount int(8))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT THIRDPEOPLE_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE lot b SET b.cow_amount = cow_amount WHERE b.id_lot = id_lot;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_LOT; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOT(IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id_lot) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_lot);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM lot b WHERE b.id_lot = id_lot;
        COMMIT;
    END;
END;;
DELIMITER ;

-- OPERATION ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_OPERATION; -- OBTIENE UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE GET_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
		END IF;
        SELECT * FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_OPERATIONS; -- CREA UN REGISTRO EN LA TABLA OPERATIONS
DELIMITER ;;
CREATE PROCEDURE CREATE_OPERATIONS(IN id_cow int, in id_third int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		SELECT "HA OCURRIDO UN ERROR" AS MESSAGE;
		ROLLBACK;
	END; 
	START TRANSACTION;
    BEGIN
		INSERT INTO operation VALUES(NULL, id_cow ,  id_third , NORMALIZE_TEXT( operation ));
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_OPERATION; -- ACTUALIZA UNA OPERACION CON EL ID ESPECIFICADO
DELIMITER ;;
CREATE PROCEDURE UPDATE_OPERATION(IN id_operation int, IN operation varchar(12))
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
		UPDATE operation b SET b.operation = operation WHERE b.id_operation = id_operation;
		COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_OPERATION; -- ELIMINA UN LOTE DE LA TABLA
DELIMITER ;;
CREATE PROCEDURE DELETE_OPERATION(IN id_operation INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT OPERATION_EXISTS(id_operation) THEN
			SET @message = CONCAT('NO EXISTE REGISTRO PARA ', id_operation);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @message;
        END IF;
        DELETE FROM operation b WHERE b.id_operation = id_operation;
        COMMIT;
    END;
END;;
DELIMITER ;

-- LOTCOW ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DROP PROCEDURE IF EXISTS GET_LOTCOW; -- OBTIENE TODAS LAS VACAS CON RAZA
DELIMITER ;; 
CREATE PROCEDURE GET_LOTCOW()
BEGIN
	SELECT * FROM lotcow_view;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS CREATE_LOTCOW; -- CREA UN NUEVO REGISTRO PARA LAS VACAS CON RAZA
DELIMITER ;;
CREATE PROCEDURE CREATE_LOTCOW(IN id_lot INT, IN id_cow INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT (COW_EXISTS(id_cow) AND LOT_EXISTS(id_lot)) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ALGUNO DE LOS ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		IF NOT COW_ISALIVE(id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA ';
        END IF;
        
		SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		
		INSERT INTO lotcow VALUES(NULL, id_lot, id_cow);
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS UPDATE_LOTCOW; -- ACTUALIZA EL LOTE 
DELIMITER ;;
CREATE PROCEDURE UPDATE_LOTCOW(IN id INT, IN id_lot INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOT_EXISTS(id) THEN
			CALL ERROR_RESPONSE(CONCAT('NO HAY UN REGISTRO PARA ', id));
        END IF;
		IF NOT LOT_EXISTS(id_lot) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO EXISTE ESA LOTE';
        END IF;
        
        -- OBTIENE EL ID DE LA VACA PAR COMPROBAR SI ESTA VIVA
        SET @id_cow = NULL;
        SELECT bc.id_cow FROM lotcow bc where bc.id = id INTO @id_cow; 
		IF NOT COW_ISALIVE(@id_cow) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'NO SE LE PUEDE ASIGNAR UN LOTE A UNA VACA YA MUERTA bro';
        END IF;
        
        -- OBTIENE EL ID DEL LOTE PARA
        SET @idAlreadyExists = NULL;
		SELECT bc.id_lot FROM lotcow bc WHERE bc.id_lot = id_lot AND bc.id_cow = id_cow INTO @idAlreadyExists;
        IF @idAlreadyExists IS NOT NULL THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'ESTAS INTENTANDO ASIGNAR A LA VACA UN LOTE QUE YA POSEE';
        END IF;
		UPDATE lotcow bc SET bc.id_lot = id_lot WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;

DROP PROCEDURE IF EXISTS DELETE_LOTCOW; -- ELIMINA UNA RAZA PARA LA VACA ESPECIFICADA
DELIMITER ;;
CREATE PROCEDURE DELETE_LOTCOW(IN id INT)
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
		SELECT @p2 AS MESSAGE;
		ROLLBACK;
	END;
    START TRANSACTION;
    BEGIN
		IF NOT LOTCOW_EXISTS(id) THEN
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL ID ESPECIFICADO NO SE ENCUENTRA COMO UN REGISTRO';
        END IF;
		DELETE FROM lotcow bc WHERE bc.id = id;
        COMMIT;
    END;
END;;
DELIMITER ;